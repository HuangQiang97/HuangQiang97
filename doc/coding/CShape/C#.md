







<center><h1>C#</h1></center>



[toc]

[C#规范](https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/language-specification/introduction)

## 基础

### 1、 开始

```c#

using System;//包含 System 命名空间
namespace HelloWorldApplication //一个 namespace 里包含了一系列的类
{
   class HelloWorld //文件名可以不同于类的名称。
   {
       /* 程序的执行从 Main 方法开始，Main 方法是所有 C# 程序的 入口点，
       说明当类执行时 类将做什么动作。*/
      static void Main(string[] args) 
      {
         Console.WriteLine("msg:{0}","Hello World");//类似于print(),{编号}为占位符
         Console.ReadKey();//等待输入。
      }
   }
}
```

### 2、基本语法

>标识符必须以字母、下划线或 @ 开头，后面可以跟一系列的字母、数字（ 0 - 9 ）、下划线（ _ ）、@。
>
>标识符不能是 C# 关键字。除非它们有一个 @ 前缀。

**保留关键字**

| abstract  | as        | base     | bool       | break                    | byte                   | case    |
| --------- | --------- | -------- | ---------- | ------------------------ | ---------------------- | ------- |
| catch     | char      | checked  | class      | const                    | continue               | decimal |
| default   | delegate  | do       | double     | else                     | enum                   | event   |
| explicit  | extern    | false    | finally    | fixed                    | float                  | for     |
| foreach   | goto      | if       | implicit   | in                       | in (generic  modifier) | int     |
| interface | internal  | is       | lock       | long                     | namespace              | new     |
| null      | object    | operator | out        | out  (generic  modifier) | override               | params  |
| private   | protected | public   | readonly   | ref                      | return                 | sbyte   |
| sealed    | short     | sizeof   | stackalloc | static                   | string                 | struct  |
| switch    | this      | throw    | true       | try                      | typeof                 | uint    |
| ulong     | unchecked | unsafe   | ushort     | using                    | virtual                | void    |
| volatile  | while     |          |            |                          |                        |         |

**上下文关键字**

| add               | alias  | ascending | descending | dynamic | from    | get            |
| ----------------- | ------ | --------- | ---------- | ------- | ------- | -------------- |
| global            | group  | into      | join       | let     | orderby | partial (type) |
| partial  (method) | remove | select    | set        |         |         |                |

### 3、数据类型

**值类型**

>值类型变量可以直接分配给一个值。当声明一个 值类型时，系统分配内存来存储值。

| 类型    | 描述                                 | 范围                                                    | 默认值 |
| ------- | ------------------------------------ | ------------------------------------------------------- | ------ |
| bool    | 布尔值                               | True 或 False                                           | False  |
| byte    | 8 位无符号整数                       | 0 到 255                                                | 0      |
| char    | 16 位 Unicode 字符                   | U +0000 到 U +ffff                                      | '\0'   |
| short   | 16 位有符号整数类型                  | -32,768 到 32,767                                       | 0      |
| float   | 32 位单精度6.0浮点型                 | -3.4 x 1038 到 + 3.4 x 1038                             | 0.0F   |
| int     | 32 位有符号整数类型                  | -2,147,483,648 到 2,147,483,647                         | 0      |
| double  | 64 位双精度浮点型                    | (+/-)5.0 x 10-324 到 (+/-)1.7 x 10308                   | 0.0D   |
| sbyte   | 8 位有符号整数类型                   | -128 到 127                                             | 0      |
| ushort  | 16 位无符号整数类型                  | 0 到 65,535                                             | 0      |
| uint    | 32 位无符号整数类型                  | 0 到 4,294,967,295                                      | 0      |
| long    | 64 位有符号整数类型                  | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 | 0L     |
| ulong   | 64 位无符号整数类型                  | 0 到 18,446,744,073,709,551,615                         | 0      |
| decimal | 128 位精确的十进制值，28-29 有效位数 | (-7.9 x 1028 到 7.9 x 1028)  / 100 到 28                | 0.0M   |

>得到一个类型或一个变量在特定平台上的准确尺寸,表达式 *sizeof(type)* 产生以字节为单位存储对象或类型的存储尺寸

**引用类型**

>引用类型不包含存储在变量中的实际数据，但它们包含对变量的引用,它们指的是一个内存位置。
>
>内置引用类型有：**object**、**dynamic** 和 **string**。

>对象（Object）类型 是 C# 通用类型系统（Common Type System - CTS）中所有数据类型的终极基类。
>
>对象（Object）类型可以被分配任何其他类型（值类型、引用类型、预定义类型或用户自定义类型）的值.
>
>```
>Object obg = 1;
>```

>动态(dynamic)类型可以存储任何类型的值在动态数据类型变量中，这些变量的类型检查是在运行时发生的。
>
>动态类型与对象类型相似，但是对象类型变量的类型检查是在编译时发生的，而动态类型变量的类型检查是在运行时发生的。
>
>```
>dynamic val="str";
>val.GetType();//获得实际类型。
>```

>字符串（String）类型允许给变量分配任何字符串值,可以通过两种形式进行分配：引号和 @引号。
>
>字符串的前面可以加 @（称作"逐字字符串"）将转义字符（\）、空格、换行符当作普通字符对待，即不解释字符串。
>
>```
>string str = "a\ta";// "a    a"
>
>string str = @"a\ta";// "a\ta"
>```

>指针类型变量存储另一种类型的内存地址: **type* identifier;**

### 4、类型转换

>```
>val=(type)val;
>val=Convert.func(val);
>```

| 序号 | 方法 & 描述                                                  |
| ---- | ------------------------------------------------------------ |
| 1    | **ToBoolean** 如果可能的话，把类型转换为布尔型。             |
| 2    | **ToByte** 把类型转换为字节类型。                            |
| 3    | **ToChar** 如果可能的话，把类型转换为单个 Unicode 字符类型。 |
| 4    | **ToDateTime** 把类型（整数或字符串类型）转换为 日期-时间 结构。 |
| 5    | **ToDecimal** 把浮点型或整数类型转换为十进制类型。           |
| 6    | **ToDouble** 把类型转换为双精度浮点型。                      |
| 7    | **ToInt16** 把类型转换为 16 位整数类型。                     |
| 8    | **ToInt32** 把类型转换为 32 位整数类型。                     |
| 9    | **ToInt64** 把类型转换为 64 位整数类型。                     |
| 12   | **ToString** 把类型转换为字符串类型。                        |
| 13   | **ToType** 把类型转换为指定类型。                            |
| 14   | **ToUInt16** 把类型转换为 16 位无符号整数类型。              |
| 15   | **ToUInt32** 把类型转换为 32 位无符号整数类型。              |
| 16   | **ToUInt64** 把类型转换为 64 位无符号整数类型。              |

>**Console.ReadLine()**：获得输入，以string形式返回。可通过Convert.func(val)进行类型转换。

### 5、常量

>整形常量
>
>​	前缀：0、0X,后缀：U、L、F
>
>浮点常量
>
>​	使用小数形式表示时，必须包含小数点、指数或同时包含两者。使用指数形式表示时，必须包含整数部分、小数部分或同时包含两者。3.14E-1

**转义**

| 转义序列   | 含义                       |
| ---------- | -------------------------- |
| \\\\       | \                      |
| \\'       | '                   |
| \\"        | "                      |
| \?         | ?                    |
| \a         | Alert             |
| \b         | 退格键（Backspace）        |
| \f         | 换页符（Form feed）        |
| \n         | 换行符（Newline）          |
| \r         | 回车                       |
| \t         | 水平制表符 tab             |
| \v         | 垂直制表符 tab             |

>常量使用 **const** 关键字来定义:const <data_type> <constant_name> = value;

### 6、运算符

| 运算符 | 描述                     |
| ------ | --------------------   |
| &      | 按位与                  |
| \|     | 按位或                  |
| ^      | 按位异或，同为0，异为1    |
| ~      | 按位取反                |
| <<     | 二进制左移运算符。        |
| >>     | 二进制右移运算符。        |

| 运算符   | 描述                                   | 实例                                                         |
| -------- | -------------------------------------- | ------------------------------------------------------------ |
| sizeof() | 返回数据类型的大小。                   | sizeof(int)，将返回 4.                                       |
| typeof() | 返回 class 的类型。                    | typeof(StreamReader);                                        |
| &        | 返回变量的地址。                       | &a; 将得到变量的实际地址。                                   |
| *        | 返回指针指向的变量                     | *a; 将指向一个变量。                                         |
| X?A :B   | 条件表达式                             | 如果条件为真 ? 则为 A : 否则为 B                             |
| is       | 判断对象是否为某一类型。               | If( Ford is Car)                                             |
| as       | 强制转换，即使转换失败也不会抛出异常。 | Object obj = new StringReader("Hello");                                           StringReader r = obj as StringReader; |

**运算优先级**

| 类别       | 运算符                                                       | 结合性   |
| ---------- | ------------------------------------------------------------ | -------- |
| 后缀       | ()、 []、 ->、  ++  、 - -                                   | 从左到右 |
| 一元       | +、 - 、  !、  ~、  ++ 、 - - 、  (type)  、  sizeof         | 从右到左 |
| 乘除       | *  、/ 、 %                                                  | 从左到右 |
| 加减       | +、  -                                                       | 从左到右 |
| 移位       | <<、 >>                                                      | 从左到右 |
| 关系       | <、 <= 、 >、 >=                                             | 从左到右 |
| 相等       | ==、  !=                                                     | 从左到右 |
| 位与 AND   | &                                                            | 从左到右 |
| 位异或 XOR | ^                                                            | 从左到右 |
| 位或 OR    | \|                                                           | 从左到右 |
| 逻辑与 AND | &&                                                           | 从左到右 |
| 逻辑或 OR  | \|\|                                                         | 从左到右 |
| 条件       | ? :                                                          | 从右到左 |
| 赋值       | =  、+= 、 -= 、 *= 、 /=  、%=、>>=、  <<= 、 &=、  ^=、   \|= | 从右到左 |
| 逗号       | ,                                                            | 从左到右 |

### 7、判断
>**switch** 语句中的 **expression** 必须是一个整型或枚举类型，或者是一个 class 类型，其中 class 有一个单一的转换函数将其转换为整型或枚举类型。
>
>case 的 **constant-expression** 必须与 switch 中的变量具有相同的数据类型，且必须是一个常量。
>
>C# 不允许从一个开关部分继续执行到下一个开关部分。如果 case 语句中有处理语句，则必须包含 **break** 或其他跳转语句。

### 8、循环

| 循环类型                                                     | 描述                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [while 循环](https://www.runoob.com/csharp/csharp-while-loop.html) | 当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。 |
| [for/foreach 循环](https://www.runoob.com/csharp/csharp-for-loop.html) | 多次执行一个语句序列，简化管理循环变量的代码。               |
| [do...while 循环](https://www.runoob.com/csharp/csharp-do-while-loop.html) | 当给定条件为真时，重复语句或语句组。它是在循环主体结尾测试条件， do...while 循环会确保至少执行一次循环。。 |
| [嵌套循环](https://www.runoob.com/csharp/csharp-nested-loops.html) | 您可以在 while、for 或 do..while 循环内使用一个或多个循环。  |

>使用foreach可以迭代数组或者一个集合对象。
>
>foreach(type val in vals){ ops;}

>循环控制语句更改执行的正常序列。当执行离开一个范围时，所有在该范围中创建的自动对象都会被销毁。

| 控制语句 | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| break    | 终止 **loop** 或 **switch** 语句，程序流将继续执行紧接着 loop 或 switch 的下一条语句。 |
| continue | 引起循环跳过主体的剩余部分，立即重新开始测试条件。           |

>死循环
>
>当条件表达式不存在时，它被假设为真。

### 9、封装

| 修饰符             | 范围                       |
| ------------------ | ---------------------------------------- |
| public             | 所有对象都可以访问                       |
| protected          | 只有该类对象及其子类对象可以访问         |
| internal           | 同一个程序集的对象可以访问,可以被定义在该成员所定义的应用程序内的任何类或方法访问。 |
| protected internal | 访问限于当前程序集或派生自包含类的类型。允许在本类,派生类或者包含该类的程序集中访问 |
| private            | 对象本身在对象内部可以访问；             |

>如果没有指定访问修饰符，则使用类成员的默认访问修饰符，即为 **private**。

### 10、方法

>```
><Access Specifier> <Return Type> <Method Name>(Parameter List)
>{
>Method Body;
>}
>```

 **传参方式**

| 方式     | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| 值参数   | 这种方式复制参数的实际值给函数的形式参数，实参和形参使用的是两个不同内存中的值。在这种情况下，当形参的值发生改变时，不会影响实参的值，从而保证了实参数据的安全。 |
| 引用参数 | 这种方式复制参数的内存位置的引用给形式参数。这意味着，当形参的值发生改变时，同时也改变实参的值。引用参数是一个对变量的内存位置的引用，表示与提供给方法的实际参数具有相同的内存位置。**public** **void**  func(**ref** **int** x)  {    x += 1;   }   int x=1;func(**ref** x); |
| 输出参数 | 这种方式可以返回多个值。输出参数会把方法输出的数据赋给自己，其他方面与引用参数相似。提供给输出参数的变量不需要赋值。                                                                                                                                                        **public** **void**  func(**out** **int** x)  {    x = 1;   }   int x;func(**out** x); |

>ref与out都是应用传递。
>
>使用ref型参数时，传入的参数必须先被初始化,在方法中对参数的任何更改都将反映在该变量中。
>
>对out而言，参数在传递之前不需要显式初始化，但必须在方法中对其完成初始化，即使在传入前已经声明，传入函数后即被设置为空。
>
>ref 和 out 关键字在运行时的处理方式不同，但在编译时的处理方式相同。因此，如果一个方法采用 ref 参数，而另一个方法采用 out 参数，则无法重载这两个方法。
>
>out应该是在方法内部做了分配地址的操作，然后把地址赋给外部的变量。但是ref是直接传递外部地址进方法。
>
>out适合用在需要retrun多个返回值的地方，而ref则用在需要被调用的方法修改调用者的引用的时候。

### 11、可空类型

**nullable 类型（可空类型），可空类型可以表示其基础值类型正常范围内的值，再加上一个 null 值。**

>？
>
>单问号用于对 int,double,bool 等无法直接赋值为 null 的数据类型进行 null 的赋值。                                        int a :a默认为0；int? a:a默认值null
>
>```C#
>< data_type> ? <valiable_name> = null;
>int? val = null;
>bool? val = new bool?();
>```

>??
>
>Null 合并运算符用于定义可空类型和引用类型的默认值。Null 合并运算符为类型转换定义了一个预设值，以防可空类型的值为 Null。Null 合并运算符把操作数类型隐式转换为另一个可空（或不可空）的值类型的操作数的类型。
>
>如果第一个操作数的值为 null，则运算符返回第二个操作数的值，否则返回第一个操作数的值。
>
>```
>val3 = var1 ?? val2; // if val1==null val3=val2 else val3=val1
>```

### 12、数组

>数组由连续的内存位置组成的,最低的地址对应第一个元素，最高的地址对应最后一个元素。
>
>数组是一个引用类型,声明一个数组不会在内存中创建数组,在初始化后才创建对象。
>
>```
>type [] vals=new type[size]{var,var,var};
>type [] vals={var,var,var};
>type [] vals=new type[]{var,var,var};
>```
>
>C# 编译器会根据数组类型隐式初始化每个数组元素为一个默认值。

>**多维数组**
>
>类似于多为矩阵
>
>```
>type[ ,  ] vals=new type[m,n]{{val,val},{val,val}};//声明
>vals[i,j];//访问
>vals.GetLength(k) ;//获得第k维度长度
>```
>
>
>
>

> **交错数组**
>
> 交错数组是一维数组，是数组的数组
>
> ```
> type [][] vals=new type[k][]{new type[m]{val,val},new type[n]{val,val}}
> vals.Length,vals[i].Length;//获得长度。
> vals[i]; vals[i][j];//实现访问
> ```

> 传递数组作为函数的参数,可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。

> **参数数组**
>
> 参数数组通常用于传递未知数量的参数给函数。
>
> ```
>  prite int func(params typet[] vals){ops;}
> ```

> Array 类是 C# 中所有数组的基类

**属性**

| 序号 | 属性 & 描述                                                  |
| ---- | ------------------------------------------------------------ |
| 1    | **IsFixedSize** 获取一个值，该值指示数组是否带有固定大小。   |
| 2    | **IsReadOnly** 获取一个值，该值指示数组是否只读。            |
| 3    | **Length** 获取一个 32 位整数，该值表示所有维度的数组中的元素总数。 |
| 4    | **LongLength** 获取一个 64 位整数，该值表示所有维度的数组中的元素总数。 |
| 5    | **Rank** 获取数组的秩（维度）。                              |

**方法**

| 序号 | 方法 & 描述                                                  |
| ---- | ------------------------------------------------------------ |
| 1    | **Array.Clear** 根据元素的类型，设置数组中某个范围的元素为零、为 false 或者为 null。 |
| 2    | **Array.Copy(Array, Array, Int32)** 从数组的第一个元素开始复制某个范围的元素到另一个数组的第一个元素位置。长度由一个 32 位整数指定。 |
| 3    | **obg.CopyTo(Array, Int32)** 从当前的一维数组中复制所有的元素到一个指定的一维数组的指定索引位置。索引由一个 32 位整数指定。 |
| 4    | **obg.GetLength(axis)**  获取一个 32 位整数，该值表示指定维度的数组中的元素总数。 |
| 5    | **GetLongLength** 获取一个 64 位整数，该值表示指定维度的数组中的元素总数。 |
| 6    | **GetLowerBound** 获取数组中指定维度的下界。                 |
| 7    | **GetType** 获取当前实例的类型。从对象（Object）继承。       |
| 8    | **GetUpperBound** 获取数组中指定维度的上界。                 |
| 9    | **GetValue(Int32)** 获取一维数组中指定位置的值。索引由一个 32 位整数指定。 |
| 10   | **Array.IndexOf(Array, Object)** 搜索指定的对象，返回整个一维数组中第一次出现的索引。 |
| 11   | **Array.Reverse(Array)** 逆转整个一维数组中元素的顺序。      |
| 12   | **SetValue(Object, Int32)** 给一维数组中指定位置的元素设置值。索引由一个 32 位整数指定。 |
| 13   | **Array.Sort(Array)** 使用数组的每个元素的 IComparable 实现来升序排序整个一维数组中的元素。 |
| 14   | **obg.ToString** 返回一个表示当前对象的字符串。从对象（Object）继承。 |

### 13、字符串

String 类有以下两个属性：

| 序号 | 属性名称 & 描述                                              |
| :--- | :----------------------------------------------------------- |
| 1    | **Chars** 在当前 *String* 对象中获取 *Char* 对象的指定位置。 |
| 2    | **Length** 在当前的 *String* 对象中获取字符数。              |

### 14、String 类的方法

String 类有许多方法用于 string 对象的操作。下面的表格提供了一些最常用的方法：

| 序号 | 方法名称 & 描述                                              |
| :--- | :----------------------------------------------------------- |
| 1   | **public static int Compare( string strA, string strB, bool ignoreCase )** 比较两个指定的 string 对象，小于0:strA小于strB;等于0:strA等于trB;大于0:strA大于strB，如果布尔参数为真时，该方法不区分大小写。 |
| 2   | **public static bool Equals( string a, string b )** 判断两个指定的 string 对象是否具有相同的值。 |
| 3   | **public static string Copy( string str )** 创建一个与指定字符串具有相同值的新的 String 对象。 |
| 4    | **public static string Format( string format, Object arg0 )** 把指定字符串中一个或多个格式项替换为指定对象的字符串表示形式。类似于**Console.Write();** |
| 5    | **public static string Join( string separator, string[] value)** 连接接一个字符串数组，使用指定的分隔符分隔每个元素。 |
| 6    | **public static string Concat( string str0, string str1 )** 连接两个 string 对象。 |
| 7   | **public bool Equals( string value )** 判断当前的 string 对象是否与指定的 string 对象具有相同的值。 |
| 8   | **public string ToLower()** 把字符串转换为小写并返回。 |
| 9   | **public string ToUpper()** 把字符串转换为大写并返回。|
| 10  |**public char[] ToCharArray(  )** 返回一个带有当前 string 对象中所有字符的 Unicode 字符数组.  |
| 11  | **public int IndexOf( string value )** 返回指定字符串在该实例中第一次出现的索引，索引从 0 开始。 |
| 12   | **public int IndexOf( char value )** 返回指定 Unicode 字符在当前字符串中第一次出现的索引，索引从 0 开始。 |
| 13   | **public int LastIndexOf( string value )** 返回指定字符串在当前 string 对象中最后一次出现的索引位置，索引从 0 开始。 |
| 14   |  **public bool Contains( string value )** 返回一个表示指定 string 对象是否出现在字符串中的值。 |
| 15   | **public string Insert( int startIndex, string value )** 返回一个新的字符串，其中，指定的字符串被插入在当前 string 对象的指定索引位置。 |
| 16   | **public string Trim()** 移除当前 String 对象中的所有前导空白字符和后置空白字符。 |
| 17   | **public string Remove( int startIndex, int count )** 从当前字符串的指定位置开始移除指定数量的字符，并返回字符串。 |
| 18   | **public string Replace( string oldValue, string newValue )** 把当前 string 对象中，所有指定的字符串替换为另一个指定的字符串，并返回新的字符串。 |
| 19 | **public bool StartsWith( string value )** 判断字符串实例的开头是否匹配指定的字符串。 |
| 20 | **public bool EndsWith( string value )** 判断 string 对象的结尾是否匹配指定的字符串。 |

### 15、结构

> 结构体是值类型数据结构。它使得一个单一变量可以存储各种数据类型的相关数据。
>
> - 结构可带有方法、字段、索引、属性、运算符方法和事件。
> - 结构可定义构造函数，但不能定义析构函数。但是，您不能为结构定义无参构造函数。无参构造函数(默认)是自动定义的，且不能被改变。
> - 与类不同，结构不能继承其他的结构或类。
> - 结构不能作为其他结构或类的基础结构。
> - 结构可实现一个或多个接口。
> - 结构成员不能指定为 abstract、virtual 或 protected。
> - 当使用 **New** 操作符创建一个结构对象时，会调用适当的构造函数来创建结构。与类不同，结构可以不使用 New 操作符即可被实例化。
> - 如果不使用 New 操作符，只有在所有的字段都被初始化之后，字段才被赋值，对象才被使用。
> - 类是引用类型，结构是值类型。
> - 结构不支持继承。
> - 结构不能声明默认的构造函数。
> - 结构体中声明的字段无法赋予初值，但类可以。
> - 结构体的构造函数中，必须为结构体所有字段赋值，类的构造函数无此限制。
> - 结构是值类型，它在栈中分配空间；而类是引用类型，它在堆中分配空间，栈中保存的只是引用。
> - 在一个对象的主要成员为数据且数据量不大的情况下，使用结构会带来更好的性能。

```
struct str
{
public int val;
public void func(int param)
	{
   	 ops;
	}
};
str strVal=new str();
strVal.val;
strVal.func(param);

```

>结构和类的适用场合分析：
>
>-  1、当堆栈的空间很有限，且有大量的逻辑对象时，创建类要比创建结构好一些；
>-  2、对于轻量对象，假如要声明一个含有许多对象的数组，则CLR需要为每个对象分配内存，在这种情况下，使用结构的成本较低；
>- 3、在表现抽象和多级别的对象层次时，类是最好的选择，因为结构不支持继承。
>- 4、大多数情况下，目标类型只是含有一些数据，或者以数据为主。

### 16、枚举

> 枚举是一组命名整型常量,枚举是值类型。枚举包含自己的值，且不能继承或传递继承。

```
enum <enum_name>
{ 
    enumeration list ;// 是一个用逗号分隔的标识符列表。
};

enum_name.val;//获得枚举对象，对象为特殊枚举成员类型
(int) enmu_name.val;//获得对象的整数值

enum Day { Sun, Mon, Tue, Wed, Thu, Fri, Sat }; //默认数值
enum Days {Mon=1, tue=2, Wed=3, thu=4, Fri=5, Sat=6, Sun=7}; //自定义数值
```

> 枚举列表中的每个符号代表一个整数值，一个比它前面的符号大的整数值。默认情况下，第一个枚举符号的值是 0.

### 17、类

```
<access specifier> class  class_name
{
    // member variables
    <access specifier> <data type> variableN;
	// 构造函数
     <access specifier> class_name(parameter_list)
    {
        // method body
    }
    //析构函数
    ~class_name(){
        // method body
    }
    // member methods
    <access specifier> <return type> methodN(parameter_list)
    {
        // method body
    }
}
```

> 类的默认访问标识符是 **internal**，成员的默认访问标识符是 **private**。
>
> 类的成员函数是一个在类定义中有它的定义或原型的函数，就像其他变量一样。作为类的一个成员，它能在类的任何对象上操作，且能访问该对象的类的所有成员。
>
> 成员变量是对象的属性（从设计角度），且它们保持私有来实现封装。这些变量只能使用公共成员函数来访问。

>    	类的构造函数 是类的一个特殊的成员函数，当创建类的新对象时执行。构造函数的名称与类的名称完全相同，它没有任何返回类型。默认的构造函数没有任何参数。

>析构函数的名称是在类的名称前加上一个波浪形（~）作为前缀，它不返回值，也不带任何参数。
>
>析构函数用于在结束程序（比如关闭文件、释放内存等）之前释放资源。析构函数不能继承或重载。

>**static** 关键字把类成员(变量,函数)定义为静态的。意味着无论有多少个类的对象被创建，只会有一个该静态成员,类中只有一个该成员的实例,所有对象对他的修改都作用在该静态成员上。
>
>静态变量用于定义常量，它们的值可以通过直接调用类而不需要创建类的实例来获取。如果不声明为static，即使和Main方法从属于同一个类，也必须经过实例调用变量,静态变量可在成员函数或类的定义外部进行初始化。也可以在类的定义内部初始化静态变量。
>
>一个**成员函数**声明为 **static**。这样的函数只能访问静态变量。静态函数在对象被创建之前就已经存在。

>Main函数可以视为类的一个成员函数,可以正常访问类的所有静态变量与静态函数.

### 18、继承

> **class** <派生类> : <基类> { }

>派生类继承了基类的成员变量和成员方法。因此父类对象应在子类对象创建之前被创建。可以在成员初始化列表中进行显式父类的初始化。
>
>```
> public SubClass(double l, double w,double,h) : base(l, w)
> {
> ops;
> }
>```
>
>子类可以显示调用父类静态方法，访问父类静态变量：
>
>```
>base.methodName();
>base.val;
>```

> **C# 不支持多重继承**

### 19、多态

>多态是同一个行为具有多个不同表现形式或形态的能力。
>
>**多态性**意味着有多重形式。在面向对象编程范式中，多态性往往表现为"一个接口，多个功能"。
>
>多态性可以是静态的或动态的。
>
>在**静态多态性**中，函数的响应是在编译时发生的。在**动态多态性**中，函数的响应是在运行时发生的。
>
>在 C# 中，每个类型都是多态的，因为包括用户定义类型在内的所有类型都继承自 Object。
>
>多态就是同一个接口，使用不同的实例而执行不同操作

> **静态多态性**
>
> 在编译时，函数和对象的连接机制被称为早期绑定，也被称为静态绑定。C# 提供了两种技术来实现静态多态性。分别为：
>
> - 函数重载
>
>   可以在同一个范围内对相同的函数名有多个定义。函数的定义必须彼此不同，可以是参数列表中的参数类型不同，也可以是参数个数不同，即参数列表必须不相同，返回值类型可以不相同。**不能重载只有返回类型不同的函数声明。**
>
> - 运算符重载

> **动态多态性**
>
> 动态多态性是通过 **抽象类** 和 **虚方法** 实现的。
>
> ---------------------
>
> 
>
> 使用关键字 **abstract** 创建抽象类，用于提供接口的部分类的实现。当一个派生类继承自该抽象类时，实现即完成。**抽象类**包含抽象方法，抽象方法可被派生类实现。派生类具有更专业的功能。
>
> 有关抽象类的一些规则：
>
> - 不能创建一个抽象类的实例。
>
> - 不能在一个抽象类外部声明一个抽象方法。
>
> - 通过在类定义前面放置关键字 **sealed**，可以将类声明为**密封类**。当一个类被声明为 **sealed** 时，它不能被继承。抽象类不能被声明为 sealed。
>
> ```
>   abstract class base_class
>    {
>        abstract public int method_name();
>    }
>    class sub_class:  base_class
>    {
>    		 public override int method_name ()
>       	 {
>       	 		ops;
>       	 }
>    }
> ```
>
> -----------------------------------
>
> 
>
> 当有一个定义在类中的函数需要在继承类中实现时，可以使用**虚方法**。
>
> 对虚方法的调用是在运行时发生的,虚方法是使用关键字 **virtual** 声明的。
>
> ```
> public class base_class
> {
> 	public virtual void func()
>     {
>         ops;
>     }
>  }
> class sub_class:  base_class
> {
>    	public override void func() ()
>     {
>      	ops;
>     }
>  }
> ```
>
> ```
> Base obj=new Base();
> ong.func();//调用父类虚方法
> SubClass obg=new SubClass();
> obg.func();//调用子类重写的虚方法
> Base obg=new SubClass();
> obg.func();//调用子类的虚方法
> 
> ```
>
> 常见重写虚方法：
>
> ```
>  public override string ToString()
>  {
>  		return some_str;
>  }
> ```
>
> 

>virtual和abstract都是用来修饰父类的，通过覆盖父类的定义，让子类重新定义。
>
>- 1.virtual修饰的方法必须有实现（哪怕是仅仅添加一对大括号),而abstract修饰的方法一定不能实现。抽象方法是一种强制派生类覆盖的方法。
>- 2.virtual可以被子类重写，虚方法也可以被直接调用，而abstract必须被子类重写，抽象类无法实例化，所以抽象方法没有办法被调用。
>- 3.如果类成员被abstract修饰，则该类前必须添加abstract，因为只有抽象类才可以有抽象方法。但虚方法可以存在于正常类中。
>- 4.无法创建abstract类的实例，只能被继承无法实例化。

>重载和重写
>
>- 重载(overload)是提供了一种机制, 在同一个作用域(一般指一个类)相同函数名通过不同的返回值类型以及参数来表来区分的机制。
>
>- 重写(override)是用于子类中为满足自己的需要重写基类的虚方法,这样在派生类中提供一个新的方法。他们必须：相同的方法名，相同的参数列表，相同的返回值。

> **隐藏方法**
>
> 在派生类中定义的和基类中的某个方法同名的方法，使用 new 关键字定义。
>
> ```
> 父类：public void func(){ops;}
> 子类：public new void func(){ops;}或 new public  void func(){ops;}
> ```
>
> - 隐藏方法不但可以隐藏基类中的虚方法，而且也可以隐藏基类中的非虚方法。
>
> - 隐藏方法中父类的实例调用父类的方法，子类的实例调用子类的方法。
>
> - 重写方法中子类的变量调用子类重写的方法，父类的变量要看这个父类引用的是子类的实例还是本身的实例，如果引用的是父类的实例那么调用基类的方法，如果引用的是派生类的实例则调用派生类的方法。
>
> ```
> Base obj=new Base();
> ong.func();//调用父类方法
> SubClass obg=new SubClass();
> obg.func();//调用子类方法
> Base obg=new SubClass();
> obg.func();//调用父类的虚方法
> ```

### 20、运算符重载

> 重载运算符是具有特殊名称的函数，是通过关键字 **operator** 后跟运算符的符号来定义的。与其他函数一样，重载运算符有返回类型和参数列表。

```
public static result-type operator unary-operator ( op-type operand ) //重载一元运算符
public static result-type operator binary-operator (op-type1 ope1,op-type2 ope2)//重载一元运算符

class A
{
	public static return_type operator + (A a,A b)
      {
      		ops;
      }
}
```

| 运算符                                | 描述                                         |
| :------------------------------------ | :------------------------------------------- |
| +, -, !, ~, ++, --                    | 这些一元运算符只有一个操作数，且可以被重载。 |
| +, -, *, /, %                         | 这些二元运算符带有两个操作数，且可以被重载。 |
| ==, !=, <, >, <=, >=                  | 这些比较运算符可以被重载。                   |
| &&, \|\|                              | 这些条件逻辑运算符不能被直接重载。           |
| +=, -=, *=, /=, %=                    | 这些赋值运算符不能被重载。                   |
| =, ., ?:, ->, new, is, sizeof, typeof | 这些运算符不能被重载。                       |

> 运算符只能采用值参数，不能采用 ref 或 out 参数。
>
> C# 要求成对重载比较运算符。如果重载了==，则也必须重载!=，否则产生编译错误。同时，比较运算符必须返回bool类型的值，这是与其他算术运算符的根本区别。
>
> C# 不允许重载=运算符，但如果重载例如+运算符，编译器会自动使用+运算符的重载来执行+=运算符的操作。
>
> 运算符重载的其实就是函数重载。首先通过指定的运算表达式调用对应的运算符函数，然后再将运算对象转化为运算符函数的实参，接着根据实参的类型来确定需要调用的函数的重载，这个过程是由编译器完成。

### 21 、接口

> 接口定义了所有类继承接口时应遵循的语法合同。接口定义了语法合同 **"是什么"** 部分，派生类定义了语法合同 **"怎么做"** 部分。
>
> 接口定义了属性、方法和事件，这些都是接口的成员。接口只包含了成员的声明。成员的定义是派生类的责任。接口提供了派生类应遵循的标准结构。
>
> 接口使得实现接口的类或结构在形式上保持一致。
>
> 抽象类在某种程度上与接口类似，但是，它们大多只是用在当只有少数方法由基类声明由派生类实现时。

> 接口使用 **interface** 关键字声明，它与类的声明类似。接口声明默认是 public 的。
>
> 通常接口命令以 **I** 字母开头,实现者方法名必须与接口定义的方法名一致。
>
> - 接口方法不能用public、protected、internal、private 、abstract等修饰。因为接口里面的方法都需要由外面接口实现去实现方法体，那么其修饰符必然是 public。C# 接口中的成员默认是 public 的。
> - 接口内不能有字段变量，构造函数。
> - 接口内可以定义属性（有get和set的方法）
>
> 
>
> ```
> acess_specifier interface IMyInterface
> {
>     void return_type MethodToImplement(params);
> }
> //实现
> class InterfaceImplementer : IMyInterface
> {
> 	public void MethodToImplement()
>     {
>         ops;
>     }
> }
> ```
>
> 如果一个接口继承其他接口，那么该接口的实现类或结构就需要实现所有接口的成员。
>
> - C# 是单继承，接口是解决 C# 里面类可以同时继承多个基类的问题。
> - 接口成员不能有 new、static、abstract、override、virtual 修饰符。有一点要注意，当一个接口继承一个接口，这2个接口中有相同的方法时，可用 new 关键字隐藏父接口中的方法。
>
> ```
> interface IParentInterface
> {
>     void ParentInterfaceMethod();
> }
> 
> interface IMyInterface : IParentInterface
> {
>     void MethodToImplement();
> }
> class InterfaceImplementer : IMyInterface
> {
> 	 public void MethodToImplement()
>     {
>         ops;
>     }
> 
>     public void ParentInterfaceMethod()
>     {
>         ops;
>     }
> }
> ```

>**接口和抽象类的区别**
>
>- 接口用于规范，抽象类用于共性。抽象类是类，所以只能被单继承，但是接口却可以一次实现多个。
>- 接口中只能声明方法，属性，事件，索引器。而抽象类中可以有方法的实现，也可以定义非静态的类变量。
>- 抽象类可以提供某些方法的部分实现，接口不可以。抽象类的实例是它的子类给出的。接口的实例是实现接口的类给出的。
>- 在抽象类中加入一个方法，那么它的子类就同时有了这个方法。而在接口中加入新的方法，那么实现它的类就要重新编写
>- 接口成员被定义为公共的，但抽象类的成员也可以是私有的、受保护的、内部的或受保护的内部成员（其中受保护的内部成员只能在应用程序的代码或派生类中访问）。
>- 接口不能包含字段、构造函数、析构函数、静态成员或常量。

### 22 、命名空间

> **命名空间**的设计目的是提供一种让一组名称与其他名称分隔开的方式。
>
> 命名空间的定义是以关键字 **namespace** 开始，后跟命名空间的名称，
>
> ```
> namespace namespace_name
> {
>    // 代码声明
> }
> ```
>
> 调用支持命名空间版本的函数或变量，会把命名空间的名称置于前面
>
> ```
> namespace_name.item_name;
> ```

> **using** 关键字表明程序使用的是给定命名空间中的名称。
>
> 可以使用 **using** 命名空间指令，这样在使用的时候就不用在前面加上命名空间名称。该指令告诉编译器随后的代码使用了指定命名空间中的名称。

> 命名空间可以被嵌套，即您可以在一个命名空间内定义另一个命名空间
>
> ```
> namespace namespace_name1 
> {
>    	// 代码声明
>            namespace namespace_name2 
>            {
>              // 代码声明
>            }
> }
> ```
>
> 可以使用点（.）运算符访问嵌套的命名空间的成员
>
> ```
> base_namespace.sub_namespace.item_name;
> using base_namespace.sub_namespace;
> ```

> **using static 指令：指定无需指定类型名称即可访问其静态成员的类型**
>
> ```
> using static System.Math;
> var = PI; // 直接使用System.Math.PI
> ```
>
> **起别名**
>
> ```
> using Project = PC.MyCompany.Project;
> ```

### 23、预处理指令

>预处理器指令指导编译器在实际编译开始之前对信息进行预处理。
>
>所有的预处理器指令都是以 # 开始。且在一行上，只有空白字符可以出现在预处理器指令之前。预处理器指令不是语句，所以它们不以分号（;）结束。
>
>C# 编译器没有一个单独的预处理器，但是，指令被处理时就像是有一个单独的预处理器一样。
>
>在 C# 中，**预处理器指令用于在条件编译中起作用**。与 C 和 C++ 不同的是，它们不是用来创建宏。一个预处理器指令必须是该行上的唯一指令。

| 预处理器指令 | 描述                                                         |
| :----------- | :----------------------------------------------------------- |
| #define      | 它用于定义一系列成为符号的字符。                             |
| #undef       | 它用于取消定义符号。                                         |
| #if          | 它用于测试符号是否为真。                                     |
| #else        | 它用于创建复合条件指令，与 #if 一起使用。                    |
| #elif        | 它用于创建复合条件指令。                                     |
| #endif       | 指定一个条件指令的结束。                                     |
| #line        | 它可以让您修改编译器的行数以及（可选地）输出错误和警告的文件名。 |
| #error       | 它允许从代码的指定位置生成一个错误。                         |
| #warning     | 它允许从代码的指定位置生成一级警告。                         |
| #region      | 它可以让您在使用 Visual Studio Code Editor 的大纲特性时，指定一个可展开或折叠的代码块。 |
| #endregion   | 它标识着 #region 块的结束。                                  |

>\#define 预处理器指令创建符号常量。
>
>\#define 允许您定义一个符号，这样，通过使用符号作为传递给 #if 指令的表达式，表达式将返回 true。
>
>```
>#define symbol
>```
>
>---
>
>可以使用 #if 指令来创建一个条件指令。条件指令用于测试符号是否为真。如果为真，编译器会执行 #if 和下一个指令之间的代码。如果为假则不编译该部分代码。
>
>```
>#if symbol [operator symbol]...
>```
>
>常见运算符有：
>
>- == (等于)
>- != (不等于)
>- && (与)
>- || (或)
>
>也可以用括号把符号和运算符进行分组。
>
>条件指令用于在调试版本或编译指定配置时编译代码。
>
>**一个以 #if 指令开始的条件指令，必须显示地以一个 #endif指令终止。**
>
>条件编译在程序调试和运行上有重要的作用。比如预处理器指令可以禁止编译器编译代码的某一部分，如果计划发布两个版本的代码，即基本版本和有更多功能的企业版本，就可以使用这些预处理器指令来控制。在编译软件的基本版本时，使用预处理器指令还可以禁止编译器编译于额外功能相关的代码。另外，在编写提供调试信息的代码时，也可以使用预处理器指令进行控制。总的来说和普通的控制语句（if等）功能类似，方便在于预处理器指令包含的未执行部分是不需要编译的。
>
>```
>#define DEBUG
>#define VC_V10
>using System;
>public class TestClass
>{
>   public static void Main()
>   {
>
>      #if (DEBUG && !VC_V10)
>         Console.WriteLine("DEBUG is defined");
>      #elif (!DEBUG && VC_V10)
>         Console.WriteLine("VC_V10 is defined");
>      #elif (DEBUG && VC_V10)
>         Console.WriteLine("DEBUG and VC_V10 are defined");
>      #else
>         Console.WriteLine("DEBUG and VC_V10 are not defined");
>      #endif
>      Console.ReadKey();
>   }
>}
>```
>
>---
>
>**#warning 和 #error：**
>
>当编译器遇到它们时，会分别产生警告或错误。如果编译器遇到 #warning 指令，会给用户显示 #warning 指令后面的文本，之后编译继续进行。如果编译器遇到 #error 指令，就会给用户显示后面的文本，作为一条编译错误消息，然后会立即退出编译。
>
>```
>#if DEBUG && RELEASE  
>#error ("msg")
>#endif  
>#warning ("msg")
>```
>
>---
>
> **#region 和 #endregion**:\#region 和 #endregion 指令用于把一段代码标记为有给定名称的一个块.
>
>---
>
>\#line 指令可以用于改变编译器在警告和错误信息中显示的文件名和行号信息
>
>---
>
>\#pragma 指令可以抑制或还原指定的编译警告。与命令行选项不同，#pragma 指令可以在类或方法级别执行，对抑制警告的内容和抑制的时间进行更精细的控制。
>
>```
>#pragma warning disable 169    // 取消编号 169 的警告（字段未使用的警告）
>public class MyClass
>{
>    int neverUsedField;       // 编译整个 MyClass 类时不会发出警告
>}
>#pragma warning restore 169   // 恢复编号 169 的警告
>```
>
>

### 24、正则

**字符转义**

> 正则表达式中的反斜杠字符（\）指示其后跟的字符是特殊字符，或应按原义解释该字符。

| 转义字符      | 描述                                                         | 模式                        |
| :------------ | :----------------------------------------------------------- | :-------------------------- |
| **\a**        | 与报警 (bell) 符 \u0007 匹配。                               | \a                          |
| **\b**        | 在字符类中，与退格键 \u0008 匹配。                           | [\b]{3,}                    |
| **\t**        | 与制表符 \u0009 匹配。                                       | (\w+)\t                     |
| **\r**        | 与回车符 \u000D 匹配,就是光标回到目前所在行的开头            | \r\n(\w+)                   |
| **\v**        | 与垂直制表符 \u000B 匹配。                                   | [\v]{2,}                    |
| **\f**        | 与换页符 \u000C 匹配。                                       | [\f]{2,}                    |
| **\n**        | 与换行符 \u000A 匹配,就是另起一新行，光标在新行的开头；      | \r\n(\w+)                   |
| **\e**        | 与转义符 \u001B 匹配。                                       | \e                          |

**字符类**

>字符类与一组字符中的任何一个字符匹配。

| 字符类                 | 描述                                                         | 模式   | 匹配                                       |
| :--------------------- | :----------------------------------------------------------- | :----- | :----------------------------------------- |
| **[character_group]**  | 匹配 character_group 中的任何单个字符。 默认情况下，匹配区分大小写。 | [mn]   | "mat" 中的 "m"，"moon" 中的 "m" 和 "n"     |
| **[^character_group]** | 非：与不在 character_group 中的任何单个字符匹配。 默认情况下，character_group 中的字符区分大小写。 | [^aei] | "avail" 中的 "v" 和 "l"                    |
| **[ first - last ]**   | 字符范围：与从 first 到 last 的范围中的任何单个字符匹配。    | [b-d]  | [b-d]irds 可以匹配 Birds、 Cirds、 Dirds   |
| **.**                  | 通配符：与除 \n 之外的任何单个字符匹配。 若要匹配原意句点字符（. 或 \u002E），您必须在该字符前面加上转义符 (\.)。 | a.e    | "have" 中的 "ave"， "mate" 中的 "ate"      |
| **\p{ name }**         | 与 *name* 指定的 Unicode 通用类别或命名块中的任何单个字符匹配。 | \p{Lu} | "City Lights" 中的 "C" 和 "L"              |
| **\P{ name }**         | 与不在 *name* 指定的 Unicode 通用类别或命名块中的任何单个字符匹配。 | \P{Lu} | "City" 中的 "i"、 "t" 和 "y"               |
| **\w**                 | 与任何单词字符匹配。                                         | \w     | "Room#1" 中的 "R"、 "o"、 "m" 和 "1"       |
| **\W**                 | 与任何非单词字符匹配。                                       | \W     | "Room#1" 中的 "#"                          |
| **\s**                 | 与任何空白字符匹配。                                         | \w\s   | "ID A1.3" 中的 "D "                        |
| **\S**                 | 与任何非空白字符匹配。                                       | \s\S   | "int __ctr" 中的 " _"                      |
| **\d**                 | 与任何十进制数字匹配。                                       | \d     | "4 = IV" 中的 "4"                          |
| **\D**                 | 匹配不是十进制数的任意字符。                                 | \D     | "4 = IV" 中的 " "、 "="、 " "、 "I" 和 "V" |

**定位点**

>定位点或原子零宽度断言会使匹配成功或失败，具体取决于字符串中的当前位置，但它们不会使引擎在字符串中前进或使用字符。

| 断言   | 描述                                                         | 模式     | 匹配                                            |
| :----- | :----------------------------------------------------------- | :------- | :---------------------------------------------- |
| **^**  | 匹配必须从字符串或一行的开头开始。                           | ^\d{3}   | "567-777-" 中的 "567"                           |
| **$**  | 匹配必须出现在字符串的末尾或出现在行或字符串末尾的 **\n** 之前。 | -\d{4}$  | "8-12-2012" 中的 "-2012"                        |
| **\A** | 匹配必须出现在字符串的开头。                                 | \A\w{4}  | "Code-007-" 中的 "Code"                         |
| **\Z** | 匹配必须出现在字符串的末尾或出现在字符串末尾的 **\n** 之前。 | -\d{3}\Z | "Bond-901-007" 中的 "-007"                      |
| **\z** | 匹配必须出现在字符串的末尾。                                 | -\d{3}\z | "-901-333" 中的 "-333"                          |
| **\G** | 匹配必须出现在上一个匹配结束的地方。                         | \G\(\d\) | "(1)(3)(5)[7](9)" 中的 "(1)"、 "(3)" 和 "(5)"   |
| **\b** | 匹配一个单词边界，也就是指单词和空格间的位置。               | er\b     | 匹配"never"中的"er"，但不能匹配"verb"中的"er"。 |
| **\B** | 匹配非单词边界。                                             | er\B     | 匹配"verb"中的"er"，但不能匹配"never"中的"er"。 |

**分组构造**

> 分组构造描述了正则表达式的子表达式，通常用于捕获输入字符串的子字符串。

| 分组构造                             | 描述                                                 | 模式                                                         | 匹配                                                         |
| :----------------------------------- | :--------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **( subexpression )**                | 捕获匹配的子表达式并将其分配到一个从零开始的序号中。 | (\w)\1                                                       | "deep" 中的 "ee"                                             |
| **(?< name >subexpression)**         | 将匹配的子表达式捕获到一个命名组中。                 | (?< double>\w)\k< double>                                    | "deep" 中的 "ee"                                             |
| **(?< name1 -name2 >subexpression)** | 定义平衡组定义。                                     | (((?'Open'\()[^\(\)]*)+((?'Close-Open'\))[^\(\)]*)+)*(?(Open)(?!))$ | "3+2^((1-3)*(3-1))" 中的 "((1-3)*(3-1))"                     |
| **(?: subexpression)**               | 定义非捕获组。                                       | Write(?:Line)?                                               | "Console.WriteLine()" 中的 "WriteLine"                       |
| **(?imnsx-imnsx:subexpression)**     | 应用或禁用 *subexpression* 中指定的选项。            | A\d{2}(?i:\w+)\b                                             | "A12xl A12XL a12xl" 中的 "A12xl" 和 "A12XL"                  |
| **(?= subexpression)**               | 零宽度正预测先行断言。                               | \w+(?=\.)                                                    | "He is. The dog ran. The sun is out." 中的 "is"、 "ran" 和 "out" |
| **(?! subexpression)**               | 零宽度负预测先行断言。                               | \b(?!un)\w+\b                                                | "unsure sure unity used" 中的 "sure" 和 "used"               |
| **(?<=subexpression)**               | 零宽度正回顾后发断言。                               | (?<=19)\d{2}\b                                               | "1851 1999 1950 1905 2003" 中的 "99"、"50"和 "05"            |
| **(?                                 | 零宽度负回顾后发断言。                               | (?<!wo)man\b                                                 | "Hi woman Hi man" 中的 "man"                                 |
| **(?> subexpression)**               | 非回溯（也称为"贪婪"）子表达式。                     | [13579](?>A+B+)                                              | "1ABB 3ABBC 5AB 5AC" 中的 "1ABB"、 "3ABB" 和 "5AB"           |



**限定符**

> 限定符指定在输入字符串中必须存在上一个元素（可以是字符、组或字符类）的多少个实例才能出现匹配项。 限定符包括下表中列出的语言元素。

| 限定符         | 描述                                                   | 模式       | 匹配                                                         |
| :------------- | :----------------------------------------------------- | :--------- | :----------------------------------------------------------- |
| *****          | 匹配上一个元素零次或多次。                             | \d*\.\d    | ".0"、 "19.9"、 "219.9"                                      |
| **+**          | 匹配上一个元素一次或多次。                             | "be+"      | "been" 中的 "bee"， "bent" 中的 "be"                         |
| **?**          | 匹配上一个元素零次或一次。                             | "rai?n"    | "ran"、 "rain"                                               |
| **{ n }**      | 匹配上一个元素恰好 n 次。                              | ",\d{3}"   | "1,043.6" 中的 ",043"， "9,876,543,210" 中的 ",876"、 ",543" 和 ",210" |
| **{ n ,}**     | 匹配上一个元素至少 n 次。                              | "\d{2,}"   | "166"、 "29"、 "1930"                                        |
| **{ n , m }**  | 匹配上一个元素至少 n 次，但不多于 m 次。[n,m]闭区间    | "\d{3,5}"  | "166"， "17668"， "193024" 中的 "19302"                      |
| ***?**         | 匹配上一个元素零次或多次，但次数尽可能少。             | \d*?\.\d   | ".0"、 "19.9"、 "219.9"                                      |
| **+?**         | 匹配上一个元素一次或多次，但次数尽可能少。             | "be+?"     | "been" 中的 "be"， "bent" 中的 "be"                          |
| **??**         | 匹配上一个元素零次或一次，但次数尽可能少。             | "rai??n"   | "ran"、 "rain"                                               |
| **{ n }?**     | 匹配前导元素恰好 n 次。                                | ",\d{3}?"  | "1,043.6" 中的 ",043"， "9,876,543,210" 中的 ",876"、 ",543" 和 ",210" |
| **{ n ,}?**    | 匹配上一个元素至少 n 次，但次数尽可能少。              | "\d{2,}?"  | "166"、 "29" 和 "1930"                                       |
| **{ n , m }?** | 匹配上一个元素的次数介于 n 和 m 之间，但次数尽可能少。 | "\d{3,5}?" | "166"， "17668"， "193024" 中的 "193" 和 "024"               |

**反向引用构造**

> 反向引用允许在同一正则表达式中随后标识以前匹配的子表达式。

| 反向引用构造   | 描述                                | 模式                  | 匹配             |
| :------------- | :---------------------------------- | :-------------------- | :--------------- |
| **\ number**   | 反向引用。 匹配编号子表达式的值。   | (\w)\1                | "seek" 中的 "ee" |
| **\k< name >** | 命名反向引用。 匹配命名表达式的值。 | (?< char>\w)\k< char> | "seek" 中的 "ee" |

**备用构造**

> 备用构造用于修改正则表达式以启用 either/or 匹配。

| 备用构造                        | 描述                                                         | 模式                                 | 匹配                                                         |
| :------------------------------ | :----------------------------------------------------------- | :----------------------------------- | :----------------------------------------------------------- |
| **\|**                          | 匹配以竖线 (\|) 字符分隔的任何一个元素。                     | th(e\|is\|at)                        | "this is the day. " 中的 "the" 和 "this"                     |
| **(?( expression )yes \| no )** | 如果正则表达式模式由 expression 匹配指定，则匹配 *yes*；否则匹配可选的 *no* 部分。 expression 被解释为零宽度断言。 | (?(A)A\d{2}\b\|\b\d{3}\b)            | "A10 C103 910" 中的 "A10" 和 "910"                           |
| **(?( name )yes \| no )**       | 如果 name 或已命名或已编号的捕获组具有匹配，则匹配 *yes*；否则匹配可选的 *no*。 | (?< quoted>")?(?(quoted).+?"\|\S+\s) | "Dogs.jpg "Yiska playing.jpg"" 中的 Dogs.jpg 和 "Yiska playing.jpg" |

**替换**

> 替换是替换模式中使用的正则表达式。

| 字符            | 描述                                 | 模式                                 | 替换模式          | 输入字符串 | 结果字符串   |
| :-------------- | :----------------------------------- | :----------------------------------- | :---------------- | :--------- | :----------- |
| **$**number     | 替换按组 *number* 匹配的子字符串。   | \b(\w+)(\s)(\w+)\b                   | $3$2$1            | "one two"  | "two one"    |
| **${**name**}** | 替换按命名组 *name* 匹配的子字符串。 | \b(?< word1>\w+)(\s)(?< word2>\w+)\b | ${word2} ${word1} | "one two"  | "two one"    |
| **$$**          | 替换字符"$"。                        | \b(\d+)\s?USD                        | $$$1              | "103 USD"  | "$103"       |
| **$&**          | 替换整个匹配项的一个副本。           | (\$*(\d*(\.+\d+)?){1})               | **$&              | "$1.30"    | "**$1.30**"  |
| **$`**          | 替换匹配前的输入字符串的所有文本。   | B+                                   | $`                | "AABBCC"   | "AAAACC"     |
| **$'**          | 替换匹配后的输入字符串的所有文本。   | B+                                   | $'                | "AABBCC"   | "AACCCC"     |
| **$+**          | 替换最后捕获的组。                   | B+(C+)                               | $+                | "AABBCCDD" | AACCDD       |
| **$_**          | 替换整个输入字符串。                 | B+                                   | $_                | "AABBCC"   | "AAAABBCCCC" |

**杂项构造**

| 构造               | 描述                                                   | 实例                                                   |
| :----------------- | :----------------------------------------------------- | :----------------------------------------------------- |
| **(?imnsx-imnsx)** | 在模式中间对诸如不区分大小写这样的选项进行设置或禁用。 | \bA(?i)b\w+\b 匹配 "ABA Able Act" 中的 "ABA" 和 "Able" |
| **(?#注释)**       | 内联注释。该注释在第一个右括号处终止。                 | \bA(?#匹配以A开头的单词)\w+\b                          |
| **#** [行尾]       | 该注释以非转义的 # 开头，并继续到行的结尾。            | (?x)\bA\w+\b#匹配以 A 开头的单词                       |

**Regex 类**

> Regex 类用于表示一个正则表达式。

| 序号 | 方法 & 描述                                                  |
| :--- | :----------------------------------------------------------- |
| 1    | **public bool IsMatch( string input )** 指示 Regex 构造函数中指定的正则表达式是否在指定的输入字符串中找到匹配项。 |
| 2    | **public bool IsMatch( string input, int startat )** 指示 Regex 构造函数中指定的正则表达式是否在指定的输入字符串中找到匹配项，从字符串中指定的开始位置开始。 |
| 3    | **public static bool IsMatch( string input, string pattern )** 指示指定的正则表达式是否在指定的输入字符串中找到匹配项。 |
| 4    | **public MatchCollection Matches( string input )** 在指定的输入字符串中搜索正则表达式的所有匹配项。 |
| 5    | **public string Replace( string input, string replacement )** 在指定的输入字符串中，把所有匹配正则表达式模式的所有匹配的字符串替换为指定的替换字符串。 |
| 6    | **public string[] Split( string input )** 把输入字符串分割为子字符串数组，根据在 Regex 构造函数中指定的正则表达式模式定义的位置进行分割。 |

### 25、异常

>C# 异常处理时建立在四个关键词之上的：**try**、**catch**、**finally** 和 **throw**。
>
>- **try**：一个 try 块标识了一个将被激活的特定的异常的代码块。后跟一个或多个 catch 块。
>
>- **catch**：程序通过异常处理程序捕获异常。catch 关键字表示异常的捕获。
>
>- **finally**：finally 块用于执行给定的语句，不管异常是否被抛出都会执行。
>
>- **throw**：当问题出现时，程序抛出一个异常。使用 throw 关键字来完成。
>
>以列出多个 catch 语句捕获不同类型的异常，以防 try 块在不同的情况下生成多个异常。
>
>```
>namespace ErrorHandlingApplication
>
>​```
>
>try
>{
>  // 引起异常的语句
>}
>catch( ExceptionName e1 )
>{
>  // 错误处理代码
>  Console.WriteLine(e1.Message);
>  throw (exceptionObj);//如果异常是直接或间接派生自 System.Exception 类,可以抛出一个对象。
>}
>catch( ExceptionName eN )
>{
>  // 错误处理代码
>  Console.WriteLine(eN.Message);
>   throw (exceptionObj);//如果异常是直接或间接派生自 System.Exception 类,可以抛出一个对象。
>}
>finally
>{
>  // 要执行的语句
>}
>```
>
>

>C# 异常是使用类来表示的。C# 中的异常类主要是直接或间接地派生于 **System.Exception** 类。
>
>**System.ApplicationException** 和 **System.SystemException** 类是派生于 System.Exception 类的异常类。
>
>**System.ApplicationException** 类支持由应用程序生成的异常。所以自定义的异常都应派生自该类。
>
>**System.SystemException** 类是所有预定义的系统异常的基类。

**常见异常**

| 异常类                            | 描述                                           |
| :-------------------------------- | :--------------------------------------------- |
| System.IO.IOException             | 处理 I/O 错误。                                |
| System.IndexOutOfRangeException   | 处理当方法指向超出范围的数组索引时生成的错误。 |
| System.ArrayTypeMismatchException | 处理当数组类型不匹配时生成的错误。             |
| System.NullReferenceException     | 处理当依从一个空对象时生成的错误。             |
| System.DivideByZeroException      | 处理当除以零时生成的错误。                     |
| System.InvalidCastException       | 处理在类型转换期间生成的错误。                 |
| System.OutOfMemoryException       | 处理空闲内存不足生成的错误。                   |
| System.StackOverflowException     | 处理栈溢出生成的错误。                         |

> 以定义自己的异常。用户自定义的异常类是派生自 **ApplicationException** 类。
>
> ```
> public class MyException: ApplicationException
> {
>    	public TMyException(string message): base(message)
>            {
>                ops;
>            }
> }
> ```
>
> 

### 26、文件IO

>一个 **文件** 是一个存储在磁盘中带有指定名称和目录路径的数据集合。当打开文件进行读写时，它变成一个 **流**。从根本上说，流是通过通信路径传递的字节序列。

| I/O 类         | 描述                               |
| :------------- | :--------------------------------- |
| BinaryReader   | 从二进制流读取原始数据。           |
| BinaryWriter   | 以二进制格式写入原始数据。         |
| BufferedStream | 字节流的临时存储。                 |
| Directory      | 有助于操作目录结构。               |
| DirectoryInfo  | 用于对目录执行操作。               |
| DriveInfo      | 提供驱动器的信息。                 |
| File           | 有助于处理文件。                   |
| FileInfo       | 用于对文件执行操作。               |
| FileStream     | 用于文件中任何位置的读写。         |
| MemoryStream   | 用于随机访问存储在内存中的数据流。 |
| Path           | 对路径信息执行操作。               |
| StreamReader   | 用于从字节流中读取字符。           |
| StreamWriter   | 用于向一个流中写入字符。           |
| StringReader   | 用于读取字符串缓冲区。             |
| StringWriter   | 用于写入字符串缓冲区。             |

> System.IO 命名空间中的 **FileStream** 类有助于文件的读写与关闭。该类派生自抽象类 Stream。
>
> 创建一个 **FileStream** 对象来创建一个新的文件，或打开一个已有的文件。
>
> ```
> using System.IO;
> ​```
> FileStream <object_name> = new FileStream( <file_name>,<FileMode Enumerator>, <FileAccess Enumerator>, <FileShare Enumerator>);
> 例如：FileStream F = new FileStream("sample.txt", FileMode.Open, FileAccess.Read, FileShare.Read);
> ```

| 参数       | 描述                                                         |
| :--------- | :----------------------------------------------------------- |
| FileMode   | **FileMode** 枚举定义了各种打开文件的方法。FileMode 枚举的成员有：                                                                                                                                                     **Append**：打开一个已有的文件，并将光标放置在文件的末尾。如果文件不存在，则创建文件。                                                                                                                                      **Create**：创建一个新的文件。如果文件已存在，则删除旧文件，然后创建新文件。                                                                                                                                            **CreateNew**：指定操作系统应创建一个新的文件。如果文件已存在，则抛出异常。                                                                                                                           **Open**：打开一个已有的文件。如果文件不存在，则抛出异常。                                                                                                                                                                             **OpenOrCreate**：指定操作系统应打开一个已有的文件。如果文件不存在，则用指定的名称创建一个新的文件打开。                                                                                                                                                    **Truncate**：打开一个已有的文件，文件一旦打开，就将被截断为零字节大小。然后我们可以向文件写入全新的数据，但是保留文件的初始创建日期。如果文件不存在，则抛出异常。 |
| FileAccess | **FileAccess** 枚举的成员有：**Read**、**ReadWrite** 和 **Write**。 |
| FileShare  | **FileShare** 枚举的成员有：                                                                                                                              **Inheritable**：允许文件句柄可由子进程继承。Win32 不直接支持此功能。                                     **None**：谢绝共享当前文件。文件关闭前，打开该文件的任何请求（由此进程或另一进程发出的请求）都将失败。                                                                                                                                                            **Read**：允许随后打开文件读取。如果未指定此标志，则文件关闭前，任何打开该文件以进行读取的请求（由此进程或另一进程发出的请求）都将失败。但是，即使指定了此标志，仍可能需要附加权限才能够访问该文件。                                                                                                                                   **ReadWrite**：允许随后打开文件读取或写入。如果未指定此标志，则文件关闭前，任何打开该文件以进行读取或写入的请求（由此进程或另一进程发出）都将失败。但是，即使指定了此标志，仍可能需要附加权限才能够访问该文件。                                                                                                         **Write**：允许随后打开文件写入。如果未指定此标志，则文件关闭前，任何打开该文件以进行写入的请求（由此进程或另一进过程发出的请求）都将失败。但是，即使指定了此标志，仍可能需要附加权限才能够访问该文件。                                                                                                                            **Delete**：允许随后删除文件。 |

>| 主题                                                         | 描述                                                         |
>| :----------------------------------------------------------- | :----------------------------------------------------------- |
>| [文本文件的读写](https://www.runoob.com/csharp/csharp-text-files.html) | 它涉及到文本文件的读写。**StreamReader** 和 **StreamWriter** 类有助于完成文本文件的读写。 |
>| [二进制文件的读写](https://www.runoob.com/csharp/csharp-binary-files.html) | 它涉及到二进制文件的读写。**BinaryReader** 和 **BinaryWriter** 类有助于完成二进制文件的读写。 |
>| [Windows 文件系统的操作](https://www.runoob.com/csharp/csharp-windows-file-system.html) | 它让 C# 程序员能够浏览并定位 Windows 文件和目录。            |

**读写文本**

> **StreamReader** 和 **StreamWriter** 类用于文本文件的数据读写。这些类从抽象基类 Stream 继承，Stream 支持文件流的字节读写。
>
> --------
>
> 
>
> **StreamReader** 类继承自抽象基类 TextReader，表示阅读器读取一系列字符。
>
> | 序号 | 方法 & 描述                                                  |
> | :--- | :----------------------------------------------------------- |
> | 1    | **public override void Close()** 关闭 StreamReader 对象和基础流，并释放任何与读者相关的系统资源。 |
> | 2    | **public override int Peek()** 返回下一个可用的字符，但不使用它。 |
> | 3    | **public override int Read()** 从输入流中读取下一个字符，并把字符位置往前移一个字符。 |
> | 4    | **public override string ReadLine()** 从输入流中读取一行字符，并把字符位置移到下一行开头。 |
>
> ```
> using (StreamReader sr = new StreamReader(filePath))
> {
>     //读
>     while ((line = sr.ReadLine()) != null)
>     {
>     	Console.WriteLine(line);
>     }      
> }
> 这里using与对象绑定，类似于python的with，不用手动关闭文件流。
> ```
>
> ---
>
> **StreamWriter** 类继承自抽象类 TextWriter，表示编写器写入一系列字符。
>
> | 序号 | 方法 & 描述                                                  |
> | :--- | :----------------------------------------------------------- |
> | 1    | **public override void Close()** 关闭当前的 StreamWriter 对象和基础流。 |
> | 2    | **public override void Flush()** 清理当前编写器的所有缓冲区，使得所有缓冲数据写入基础流。 |
> | 3    | **public virtual void Write(bool value)** 把一个布尔值的文本表示形式写入到文本字符串或流。（继承自 TextWriter。） |
> | 4    | **public override void Write( char value )** 把一个字符写入到流。 |
> | 5    | **public virtual void Write( decimal value )** 把一个十进制值的文本表示形式写入到文本字符串或流。 |
> | 6    | **public virtual void Write( double value )** 把一个 8 字节浮点值的文本表示形式写入到文本字符串或流。 |
> | 7    | **public virtual void Write( int value )** 把一个 4 字节有符号整数的文本表示形式写入到文本字符串或流。 |
> | 8    | **public override void Write( string value )** 把一个字符串写入到流。 |
> | 9    | **public virtual void WriteLine(string value)** 把字符串写入到文本字符串或流。 |
>
> ```
> using (StreamWriter sw = new StreamWriter(filePath))
> {
> 		ops;          
> }
> 这里using与对象绑定，类似于python的with，不用手动关闭文件流。
> ```
>
> 

**读写二进制数据**

> **BinaryReader** 和 **BinaryWriter** 类用于二进制文件的读写。
>
> ---
>
> **BinaryReader** 类用于从文件读取二进制数据。一个 **BinaryReader** 对象通过向它的构造函数传递 **FileStream** 对象而被创建。
>
> | 序号 | 方法 & 描述                                                  |
> | :--- | :----------------------------------------------------------- |
> | 1    | **public override void Close()** 关闭 BinaryReader 对象和基础流。 |
> | 2    | **public virtual int Read()** 从基础流中读取字符，并把流的当前位置往前移。 |
> | 3    | **public virtual bool ReadBoolean()** 从当前流中读取一个布尔值，并把流的当前位置往前移一个字节。 |
> | 4    | **public virtual byte ReadByte()** 从当前流中读取下一个字节，并把流的当前位置往前移一个字节。 |
> | 5    | **public virtual byte[] ReadBytes( int count )** 从当前流中读取指定数目的字节到一个字节数组中，并把流的当前位置往前移指定数目的字节。 |
> | 6    | **public virtual char ReadChar()** 从当前流中读取下一个字节，并把流的当前位置按照所使用的编码和从流中读取的指定的字符往前移。 |
> | 7    | **public virtual char[] ReadChars( int count )** 从当前流中读取指定数目的字节，在一个字符数组中返回数组，并把流的当前位置按照所使用的编码和从流中读取的指定的字符往前移。 |
> | 8    | **public virtual double ReadDouble()** 从当前流中读取一个 8 字节浮点值，并把流的当前位置往前移八个字节。 |
> | 9    | **public virtual int ReadInt32()** 从当前流中读取一个 4 字节有符号整数，并把流的当前位置往前移四个字节。 |
> | 10   | **public virtual string ReadString()** 从当前流中读取一个字符串。字符串以长度作为前缀，同时编码为一个七位的整数。 |
>
> ```
> BinaryReader br =new BinaryReader(new FileStream("mydata",FileMode.Open));
> 
> ```
>
> 
>
> ---
>
> **BinaryWriter** 类用于向文件写入二进制数据。一个 **BinaryWriter** 对象通过向它的构造函数传递 **FileStream** 对象而被创建。
>
> | 序号 | 方法 & 描述                                                  |
> | :--- | :----------------------------------------------------------- |
> | 1    | **public override void Close()** 关闭 BinaryWriter 对象和基础流。 |
> | 2    | **public virtual void Flush()** 清理当前编写器的所有缓冲区，使得所有缓冲数据写入基础设备。 |
> | 3    | **public virtual long Seek( int offset, SeekOrigin origin )** 设置当前流内的位置。 |
> | 4    | **public virtual void Write( bool value )** 把一个单字节的布尔值写入到当前流中，0 表示 false，1 表示 true。 |
> | 5    | **public virtual void Write( byte value )** 把一个无符号字节写入到当前流中，并把流的位置往前移一个字节。 |
> | 6    | **public virtual void Write( byte[] buffer )** 把一个字节数组写入到基础流中。 |
> | 7    | **public virtual void Write( char ch )** 把一个 Unicode 字符写入到当前流中，并把流的当前位置按照所使用的编码和要写入到流中的指定的字符往前移。 |
> | 8    | **public virtual void Write( char[] chars )** 把一个字符数组写入到当前流中，并把流的当前位置按照所使用的编码和要写入到流中的指定的字符往前移。 |
> | 9    | **public virtual void Write( double value )** 把一个 8 字节浮点值写入到当前流中，并把流位置往前移八个字节。 |
> | 10   | **public virtual void Write( int value )** 把一个 4 字节有符号整数写入到当前流中，并把流位置往前移四个字节。 |
> | 11   | **public virtual void Write( string value )** 把一个以长度为前缀的字符串写入到 BinaryWriter 的当前编码的流中，并把流的当前位置按照所使用的编码和要写入到流中的指定的字符往前移。 |
>
> ```
> BinaryWriter bw = new BinaryWriter(new FileStream("mydata",FileMode.Create));
> //读
> while (br.PeekChar() != -1)
>     {
>         line = br.ReadString();
>     }
> ```
>
> 

**文件系统操作**

>**DirectoryInfo** 类派生自 **FileSystemInfo** 类。它提供了各种用于创建、移动、浏览目录和子目录的方法。该类不能被继承。
>
>| 序号 | 属性 & 描述                                             |
>| :--- | :------------------------------------------------------ |
>| 1    | **Attributes** 获取当前文件或目录的属性。               |
>| 2    | **CreationTime** 获取当前文件或目录的创建时间。         |
>| 3    | **Exists** 获取一个表示目录是否存在的布尔值。           |
>| 4    | **Extension** 获取表示文件存在的字符串。                |
>| 5    | **FullName** 获取目录或文件的完整路径。                 |
>| 6    | **LastAccessTime** 获取当前文件或目录最后被访问的时间。 |
>| 7    | **Name** 获取该 DirectoryInfo 实例的名称。              |
>
>| 序号 | 方法 & 描述                                                  |
>| :--- | :----------------------------------------------------------- |
>| 1    | **public void Create()** 创建一个目录。                      |
>| 2    | **public DirectoryInfo CreateSubdirectory( string path )** 在指定的路径上创建子目录。指定的路径可以是相对于 DirectoryInfo 类的实例的路径。 |
>| 3    | **public override void Delete()** 如果为空的，则删除该 DirectoryInfo。 |
>| 4    | **public DirectoryInfo[] GetDirectories()** 返回当前目录的子目录。 |
>| 5    | **public FileInfo[] GetFiles()** 从当前目录返回文件列表。    |
>
>```
>DirectoryInfo mydir = new DirectoryInfo(@"path");
>```
>
>
>
>---
>
>**FileInfo** 类派生自 **FileSystemInfo** 类。它提供了用于创建、复制、删除、移动、打开文件的属性和方法，且有助于 FileStream 对象的创建。该类不能被继承。
>
>| 序号 | 属性 & 描述                                       |
>| :--- | :------------------------------------------------ |
>| 1    | **Attributes** 获取当前文件的属性。               |
>| 2    | **CreationTime** 获取当前文件的创建时间。         |
>| 3    | **Directory** 获取文件所属目录的一个实例。        |
>| 4    | **Exists** 获取一个表示文件是否存在的布尔值。     |
>| 5    | **Extension** 获取表示文件存在的字符串。          |
>| 6    | **FullName** 获取文件的完整路径。                 |
>| 7    | **LastAccessTime** 获取当前文件最后被访问的时间。 |
>| 8    | **LastWriteTime** 获取文件最后被写入的时间。      |
>| 9    | **Length** 获取当前文件的大小，以字节为单位。     |
>| 10   | **Name** 获取文件的名称。                         |
>
>| 序号 | 方法 & 描述                                                  |
>| :--- | :----------------------------------------------------------- |
>| 1    | **public StreamWriter AppendText()** 创建一个 StreamWriter，追加文本到由 FileInfo 的实例表示的文件中。 |
>| 2    | **public FileStream Create()** 创建一个文件。                |
>| 3    | **public override void Delete()** 永久删除一个文件。         |
>| 4    | **public void MoveTo( string destFileName )** 移动一个指定的文件到一个新的位置，提供选项来指定新的文件名。 |
>| 5    | **public FileStream Open( FileMode mode )** 以指定的模式打开一个文件。 |
>| 6    | **public FileStream Open( FileMode mode, FileAccess access )** 以指定的模式，使用 read、write 或 read/write 访问，来打开一个文件。 |
>| 7    | **public FileStream Open( FileMode mode, FileAccess access, FileShare share )** 以指定的模式，使用 read、write 或 read/write 访问，以及指定的分享选项，来打开一个文件。 |
>| 8    | **public FileStream OpenRead()** 创建一个只读的 FileStream。 |
>| 9    | **public FileStream OpenWrite()** 创建一个只写的 FileStream。 |

**路径操作**

>
>
>```
>string dirPath = @"D:\TestDir";
>string filePath = @"D:\TestDir\TestFile.txt";
>Console.WriteLine("<<<<<<<<<<<{0}>>>>>>>>>>", "文件路径");
>//获得当前路径
>Console.WriteLine(Environment.CurrentDirectory);
>//文件或文件夹所在目录
>Console.WriteLine(Path.GetDirectoryName(filePath));     //D:\TestDir
>Console.WriteLine(Path.GetDirectoryName(dirPath));      //D:\
>//文件扩展名
>Console.WriteLine(Path.GetExtension(filePath));         //.txt
>//文件名
>Console.WriteLine(Path.GetFileName(filePath));          //TestFile.txt
>Console.WriteLine(Path.GetFileName(dirPath));           //TestDir
>Console.WriteLine(Path.GetFileNameWithoutExtension(filePath)); //TestFile
>//绝对路径
>Console.WriteLine(Path.GetFullPath(filePath));          //D:\TestDir\TestFile.txt
>Console.WriteLine(Path.GetFullPath(dirPath));           //D:\TestDir  
>//更改扩展名
>Console.WriteLine(Path.ChangeExtension(filePath, ".jpg"));//D:\TestDir\TestFile.jpg
>//根目录
>Console.WriteLine(Path.GetPathRoot(dirPath));           //D:\      
>//生成路径
>Console.WriteLine(Path.Combine(new string[] { @"D:\", "BaseDir", "SubDir", "TestFile.txt" })); //D:\BaseDir\SubDir\TestFile.txt
>//生成随即文件夹名或文件名
>Console.WriteLine(Path.GetRandomFileName());
>//创建磁盘上唯一命名的零字节的临时文件并返回该文件的完整路径
>Console.WriteLine(Path.GetTempFileName());
>//返回当前系统的临时文件夹的路径
>Console.WriteLine(Path.GetTempPath());
>//文件名中无效字符
>Console.WriteLine(Path.GetInvalidFileNameChars());
>//路径中无效字符
>Console.WriteLine(Path.GetInvalidPathChars()); 
>```
>
>

**文件属性操作**

>
>
>```
>//use File class
>Console.WriteLine(File.GetAttributes(filePath));
>File.SetAttributes(filePath,FileAttributes.Hidden | FileAttributes.ReadOnly);
>Console.WriteLine(File.GetAttributes(filePath));
>
>//user FilInfo class
>FileInfo fi = new FileInfo(filePath);
>Console.WriteLine(fi.Attributes.ToString());
>fi.Attributes = FileAttributes.Hidden | FileAttributes.ReadOnly; //隐藏与只读
>Console.WriteLine(fi.Attributes.ToString());
>
>//只读与系统属性，删除时会提示拒绝访问
>fi.Attributes = FileAttributes.Archive;
>Console.WriteLine(fi.Attributes.ToString());
>```
>
>